# Using ROS with a Real Robot

So there will not be much to this section.  We did not succeed in transferring our code to work on a real robot platform.  We were able to demonstrate that the hardware was set up correctly, that all safety functions were working, and manual conroll vis ROS worked.  Due to shipping issues (2021-2022 COVID related) we did not receive hardware until the last few weeks of the project.  Furthermore, the camera was DOA and needed to be RMA'd and that process alone took about 3 weeks (to ship out, we still havent gotten it back.  If you have an RMA, don't listen to the manufacturer, just ship it back to the distributor).  If you would like to see what we did in regards to manual control woth ROS, you can take a look at [this tutorial](https://github.com/UniversalRobots/Universal_Robots_ROS_Driver). The RVIZ sim, joint sliders, and test_move.py were fun to play with and will give you an idea on how to send command to the robot if you examine the code.

Our main problem in trying to adapt our project to a real robot was a conflict in the ROS TCP in the Unity package and the ROS driver in the Universal Robots Package.  Because we did not have a working camera, we were forced to emulate a camera with Unity and have the robot pick and place a fake fin in the real world.  This required a second PC, with the first being the primary ROS machine.

The Unity machine would transmit the image data to the ROS machine and the ROS machine would then drop the connection to the UR3e.  Turns out, there was an issue with trying to connect to a local network with our machines only, and connecting to the internet on the UIC network on the same ethernet port on the ROS machine.  We still haven't figured out why that is a problem, but it is.  Luckily there were two ports on the ROS machine.  One for the switch that had all our devices and one for the switch connecting to the UIC network.  `IMPORTANT` We need internet connection on the ROS because the model requires a Pytorch download to run.

The next problem we ran into was that it just didnt work.  We resolved the controller conflicts (you need to disable these in the launch files.  If one package launched a configuration, the other one shouldn't launch the same one.  Find duplicate arguments being passed and disable them on one or the other.)  We configured the nodes to transmit the extracted pose data to send to the robot, but it would just hang.  No error messages or anything.  Without error message, the project devolved into trial and error. There was no more method other than to troll the forums and deliberately change code just to see what breaks.  In the end we were not able to figure it out but we hope that with our notes here we can give you a head start. Our advice, it might be better to just write a single ROS package that does everything from scratch. Rope a CS student into helping you because you will need to know C# and Python at a moderate level.  Lean on the tutorials and have every member set up and perform the simulation.  Especially use the [ROS tutorials](http://wiki.ros.org/ROS/Tutorials) and the [MoveIt! tutorials](https://github.com/ros-planning/moveit).  We didn't copy their contents in this tutorial but they were useful.

Apologies, this was supposed to be an awesome step-by-step on getting the robot to work with our amazing project, but we just didn't get there.  Hopefully everything we provided for you was enough to give you a head start and you can finish what we began.  Good luck!

Alan, Camila, Carlos, Diego, and Murad
